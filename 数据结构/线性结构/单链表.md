### 单链表（Single Linked List）

单链表是一个有序的列表，分为**带头节点的单链表**和**不带头节点的单链表**

![内存中单链表实际结构](单链表.assets/image-20220904220725092.png)

如上图，会发现：

- 链表是以节点的方式来存储的
- 每个节点都包含data域、next域
- 并且每一个节点都不一定是连续的

![带头节点单链表的逻辑结构](单链表.assets/image-20220904221821675.png)

#### 思路分析

头节点：不存放具体的数据，主要用于表示单链表的头，指向第一个节点

![单链表过程图](单链表.assets/image-20220916210525560.png)

##### (一) 添加功能（未排序）

- 创建一个辅助节点，用于表示头节点
- 通过辅助节点找到最后节点的位置
- 将最后节点位置的next域指向新节点即可



##### (二) 遍历功能

- 当链表为空时，不能遍历链表
- 需要创建一个辅助节点，用于表示头节点
- 通过辅助节点的next域获取每一个节点的信息，当next域为空时，说明已经遍历所有



##### (三) 添加功能（编号排序）

![添加功能（编号排序）示例图](单链表.assets/image-20220916223001980.png)

- 首先需要创建一个辅助节点，用于表示头节点

- 通过辅助节点找到新节点的前一个节点的位置，这时有三种情况：

  - 已经到链表最后的位置
  - 在链表的某个位置中插入（未到链表的最后）
  - 插入的新节点的编号已经存在，那么新节点就不能插入

- 当找到前一个节点的位置后：

  - 获取前一个节点的next域，这个就是最后新节点的next域，并将这个next域赋值给新节点的next域，即 新节点.next = temp.next
  - 此时新节点的next域已经有指向了，现在只需要和前面的节点合在一起即可
  - 而temp就是指向新节点的前一个节点的位置，只需将temp的next域指向新节点即可，即 temp.next = 新节点

  