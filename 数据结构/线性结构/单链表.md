### 单链表（Single Linked List）

单链表是一个有序的列表，分为**带头节点的单链表**和**不带头节点的单链表**

![内存中单链表实际结构](单链表.assets/image-20220904220725092.png)

如上图，会发现：

- 链表是以节点的方式来存储的
- 每个节点都包含data域、next域
- 并且每一个节点都不一定是连续的

![带头节点单链表的逻辑结构](单链表.assets/image-20220904221821675.png)

#### 思路分析

头节点：不存放具体的数据，主要用于表示单链表的头，指向第一个节点

![单链表过程图](单链表.assets/image-20220916210525560.png)

##### (一) 添加功能（未排序）

- 创建一个辅助节点，用于表示头节点
- 通过辅助节点找到最后节点的位置
- 将最后节点位置的next域指向新节点即可



##### (二) 遍历功能

- 当链表为空时，不能遍历链表
- 需要创建一个辅助节点，用于表示头节点
- 通过辅助节点的next域获取每一个节点的信息，当next域为空时，说明已经遍历所有



##### (三) 添加功能（编号排序）

![添加功能（编号排序）示例图](单链表.assets/image-20220916223001980.png)

- 首先需要创建一个辅助节点，用于表示头节点

- 通过辅助节点找到新节点的前一个节点的位置，这时有三种情况：

  - 已经到链表最后的位置
  - 在链表的某个位置中插入（未到链表的最后）
  - 插入的新节点的编号已经存在，那么新节点就不能插入

- 当找到前一个节点的位置后：

  - 获取前一个节点的next域，这个就是最后新节点的next域，并将这个next域赋值给新节点的next域，即 新节点.next = temp.next
  - 此时新节点的next域已经有指向了，现在只需要和前面的节点合在一起即可
  - 而temp就是指向新节点的前一个节点的位置，只需将temp的next域指向新节点即可，即 temp.next = 新节点




##### (四) 修改功能

- 首先需要创建一个辅助节点，用于表示头节点
- 要先通过辅助节点找到需要修改节点，此时有两种情况：
  - 辅助节点为空，即没有找到修改的节点
  - 辅助节点的编号和修改节点的编号相同，即找到修改的节点
- 此时，通过判断是否找到位置，有两种情况：
  - 没有找到修改的节点，输出对应的信息
  - 找到修改的节点，只需设置辅助节点的数据为修改节点的数据即可



##### (五) 删除功能

![删除功能示例图](单链表.assets/image-20220918222340349.png)

- 首先需要创建一个辅助节点，用于表示头节点
- 需要先通过辅助节点找到需要删除节点的前一个节点的位置，此时有两种情况：
  - 已经到链表的最后一个节点的位置，即没有找到需要删除的节点
  - 没有到链表的最后一个节点的位置，即找到需要删除的节点
- 此时，通过判断是否找到位置，有两种情况：
  - 没有找到删除的节点，输出对应的信息
  - 找到删除的节点，此时辅助节点指向删除节点的前一个节点，只需设置辅助节点的next域为删除节点的next域即可



#### 功能实现

##### (一) 创建节点（Node）类

用于每个节点的存储

```java
public class Node {
    private int no; // 编号
    private String name; // 名称
    private Node next; // next域，即下一个节点的指向

    public Node() {
    }

    public Node(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }

    @Override
    public String toString() {
        return "Node{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
}
```



##### (二) 创建单链表（SingleLinkedList）类

```java
public class SingleLinkedList {

    // 1.初始化一个头节点
    private Node headNode = new Node();
}
```



##### (三) 添加功能（未排序）实现

在SingleLinkedList类中实现添加节点功能的方法（未排序）

```java
    // 2.添加节点
    // （一）不考虑编号的顺序，直接获取当前链表的最后节点
    // （二）直接将最后节点的next域指向新节点即可
    public void add(Node node){
        Node temp = headNode;
        // 1.遍历链表，找到最后节点
        while (true){
            // （一）找到当前链表最后一个，退出遍历
            if (temp.getNext() == null){
                break;
            }
            // （二）还没有找到当前链表的最后一个，将temp后移到下一个节点
            temp = temp.getNext();
        }

        // 2.将新节点添加到最后，将temp的next域指向新节点即可
        temp.setNext(node);
    }
```



##### (四) 遍历功能实现

在SingleLinkedList类中实现遍历节点功能的方法

```java
    // 3.遍历链表
    public void list(){
        // 1.判断链表为空
        if (headNode.getNext() == null){
            System.out.println("遍历链表list() --> 当前单链表为空");
            return;
        }

        Node temp = headNode;

        System.out.println("遍历链表list() ---> 开始遍历");

        // 2.遍历链表
        while (true){
            // 判断是否到链表的最后
            if (temp.getNext() == null){
                break;
            }

            System.out.println(temp.getNext());

            temp = temp.getNext();
        }

        System.out.println("遍历链表list() ---> 遍历结束");
    }
```



##### (五) 添加功能（编号排序）实现

在SingleLinkedList类中实现添加节点功能的方法（编号排序）

```java
    /**
     * 4.添加节点（考虑编号的顺序）
     * （一）插入新节点时，需要先使用辅助节点（temp）找到新节点的前一个节点的位置，这时有三种情况：
     *      1. 已经到链表最后的位置
     *      2. 在链表的某个位置中插入（未到链表的最后）
     *      3. 插入的新节点的编号已经存在，那么新节点就不能插入
     * （二）当找到前一个节点的位置后：
     *      1. 获取前一个节点的next域，这个就是最后新节点的next域，并将这个next域赋值给新节点的next域，即 新节点.next = temp.next
     *      2. 此时新节点的next域已经有指向了，现在只需要和前面的节点合在一起即可
     *      3. 而temp就是指向新节点的前一个节点的位置，只需将temp的next域指向新节点即可，即 temp.next = 新节点
     * @param node 新节点
     */
    public void addByOrder(Node node){

        Node temp = headNode;

        // 标识新节点的标号是否已经存在
        boolean flag = false;

        // 1.找到新节点的插入位置的前一个节点
        while (true){
            // (一) 说明已经在链表的最后位置
            if (temp.getNext() == null){
                break;
            }

            // （二）说明插入位置的前一个节点已经找到
            if (temp.getNext().getNo() > node.getNo()){
                break;
            }

            // （三）说明插入的新节点的编号已经在链表中插入
            if (temp.getNext().getNo() == node.getNo()){
                flag = true;
                break;
            }

            // （四）辅助节点后移
            temp = temp.getNext();
        }

        // 2.判断flag的值
        if (flag){
            System.out.println("添加节点addByOrder() ---> 添加的新节点已经存在");
            return;
        }

        // 3.插入新节点到链表中
        // （一）新节点的next域指向辅助节点的下一个节点
        node.setNext(temp.getNext());
        // （二）辅助节点的next域指向新节点
        temp.setNext(node);
    }
```



##### (六) 修改功能实现

在SingleLinkedList类中实现修改节点功能的方法

```java
    // 5.修改链表
    public void update(Node node){
        Node temp = headNode.getNext();

        // 标识是否找到修改的节点
        boolean flag = false;
        while (true){
            // 判断辅助节点是否为空，为空则说明当前已经在链表的最后位置，即链表中没有找到需要修改的节点
            if (temp == null){
                break;
            }

            // 判断编号是否相同，相同则说明找到修改的编号
            if (temp.getNo() == node.getNo()){
                flag = true;
                break;
            }

            // 辅助节点后移
            temp = temp.getNext();
        }

        // 根据flag判断是否找到需要修改的节点
        if (!flag){
            System.out.println("修改链表update ---> 当前修改编号为" + node.getNo() + "的节点不存在");
            return;
        }

        // 修改节点
        temp.setName(node.getName());

        System.out.println("修改链表update ---> 编号为" + node.getNo() + "的节点修改成功");
    }
```



##### (七) 删除功能实现

在SingleLinkedList类中实现删除节点功能的方法

```java
// 6.删除节点
public void delete(int no){
    Node temp = headNode;

    // 标识是否找到需要删除的节点
    boolean flag = false;

    while (true){
        // 判断辅助节点的next域是否为空，如果为空则说明已经是当前链表的最后一个节点，即没有找到需要删除的节点
        if (temp.getNext() == null){
            break;
        }

        // 判断辅助节点的next域的编号是否和删除的编号相同，相同则说明已经找到需要删除的节点
        if (temp.getNext().getNo() == no){
            flag = true;
            break;
        }

        // 辅助节点后移
        temp = temp.getNext();
    }

    // 判断flag是否为false，为false则说明没有找到需要删除的节点
    if (!flag){
        System.out.println("删除节点delete ---> 删除的节点" + no + "在链表中不存在");
        return;
    }

    // 辅助节点的next域指向需要需要修改节点的next域
    temp.setNext(temp.getNext().getNext());
}
```



#### 扩展

##### (一) 获取单链表中有效节点个数【没有头节点】

需要创建一个辅助节点，通过辅助节点进行循环操作，每次循环有效个数 + 1，循环结束后就可以获取到单链表的有效节点个数

```java
    // 获取单链表中有效节点个数
    public int getSize(){
        // 判断头节点的next域是否为空，为空则说明当前链表中没有节点
        if (headNode.getNext() == null){
            return 0;
        }

        // 链表的有效个数
        int size = 0;
        // 获取辅助节点
        Node temp = headNode.getNext();

        // 循环获取有效个数，当辅助节点为空时，说明当前循环结束，链表的有效个数已经获取到
        while (temp != null){
            // 每次循环有效个数 + 1
            size++;
            // 辅助节点后移
            temp = temp.getNext();
        }
        return size;
    }
```



##### (二) 获取单链表倒数第n个节点

